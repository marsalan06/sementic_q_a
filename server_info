# Function Call Flow & Working Process

## ğŸ”„ Application Startup Flow

### Main Entry Point
```
main() 
â”œâ”€â”€ DEBUG_SESSION = False (debug logging)
â”œâ”€â”€ initialize_session() 
â”‚   â”œâ”€â”€ get_session_id() (create unique tab ID)
â”‚   â”œâ”€â”€ get_session_token() 
â”‚   â”‚   â”œâ”€â”€ st.session_state.get('token', None)
â”‚   â”‚   â””â”€â”€ st.query_params.get('token', None) (fallback)
â”‚   â”œâ”€â”€ get_mongo_session(token) 
â”‚   â”œâ”€â”€ get_user_by_id(user_id) 
â”‚   â”œâ”€â”€ set_session_user(user) 
â”‚   â””â”€â”€ update_mongo_session(token, user)
â”œâ”€â”€ check_auth() 
â”‚   â”œâ”€â”€ get_session_token() 
â”‚   â”œâ”€â”€ get_mongo_session(token) 
â”‚   â”œâ”€â”€ get_session_info(token) 
â”‚   â”œâ”€â”€ refresh_session_if_needed() (if expiring)
â”‚   â””â”€â”€ delete_mongo_session(token) (if expired)
â”œâ”€â”€ refresh_session_if_needed() 
â”‚   â”œâ”€â”€ get_session_info(token) 
â”‚   â”œâ”€â”€ refresh_session_token(token) 
â”‚   â”œâ”€â”€ set_session_token(refreshed_token) 
â”‚   â”œâ”€â”€ save_session_to_mongo() 
â”‚   â””â”€â”€ set_session_persistent()
â””â”€â”€ main_app() OR login_page() OR signup_page()
```

---

## ğŸ” Login Flow

### User Authentication Process
```
login_page() 
â”œâ”€â”€ st.form("login_form") 
â”œâ”€â”€ authenticate_user(username, password) 
â”‚   â”œâ”€â”€ get_db() 
â”‚   â”œâ”€â”€ db.users.find_one({"username": username}) 
â”‚   â”œâ”€â”€ verify_password(password, hashed) 
â”‚   â”œâ”€â”€ bcrypt.checkpw() 
â”‚   â””â”€â”€ db.users.update_one() (update last_login)
â”œâ”€â”€ set_session_user(user) 
â”œâ”€â”€ create_session_token(user["_id"], user["username"]) 
â”‚   â”œâ”€â”€ jwt.encode(payload, JWT_SECRET, algorithm="HS256") 
â”‚   â””â”€â”€ payload = {user_id, username, exp, iat}
â”œâ”€â”€ set_session_token(token) 
â”œâ”€â”€ save_session_to_mongo() 
â”‚   â”œâ”€â”€ get_mongo_session(token) 
â”‚   â”œâ”€â”€ update_mongo_session(token, user) 
â”‚   â””â”€â”€ create_mongo_session(user["_id"], user["username"], token) 
â”‚       â”œâ”€â”€ cleanup_expired_sessions() 
â”‚       â”œâ”€â”€ db.sessions.insert_one(session) 
â”‚       â””â”€â”€ session = {user_id, username, token, created_at, expires_at, is_active}
â”œâ”€â”€ set_session_persistent() 
â”‚   â””â”€â”€ st.query_params["token"] = token
â””â”€â”€ st.rerun()
```

---

## ğŸ”„ Session Restoration Flow (Page Reload)

### Token Retrieval & Validation
```
get_session_token() 
â”œâ”€â”€ token = st.session_state.get('token', None) 
â”œâ”€â”€ if not token: 
â”‚   â””â”€â”€ token = st.query_params.get('token', None) 
â”‚       â””â”€â”€ st.session_state.token = token (store for future)
â””â”€â”€ return token

initialize_session() 
â”œâ”€â”€ get_session_id() 
â”œâ”€â”€ token = get_session_token() 
â”œâ”€â”€ if token: 
â”‚   â”œâ”€â”€ mongo_session = get_mongo_session(token) 
â”‚   â”‚   â”œâ”€â”€ db.sessions.find_one({token, is_active, expires_at > now}) 
â”‚   â”‚   â””â”€â”€ db.sessions.update_one() (update last_activity)
â”‚   â”œâ”€â”€ user_id = mongo_session.get('user_id') 
â”‚   â”œâ”€â”€ user = get_user_by_id(user_id) 
â”‚   â”‚   â””â”€â”€ db.users.find_one({"_id": user_id}) 
â”‚   â”œâ”€â”€ set_session_user(user) 
â”‚   â””â”€â”€ update_mongo_session(token, user)
â””â”€â”€ else: clear_session()
```

---

## âœ… Authentication Check Flow

### Session Validation Process
```
check_auth() 
â”œâ”€â”€ token = get_session_token() 
â”œâ”€â”€ if token: 
â”‚   â”œâ”€â”€ mongo_session = get_mongo_session(token) 
â”‚   â”œâ”€â”€ if mongo_session: 
â”‚   â”‚   â”œâ”€â”€ session_info = get_session_info(token) 
â”‚   â”‚   â”‚   â””â”€â”€ jwt.decode(token, options={"verify_exp": False}) 
â”‚   â”‚   â”œâ”€â”€ if session_info and not session_info['is_expired']: 
â”‚   â”‚   â”‚   â””â”€â”€ return True 
â”‚   â”‚   â”œâ”€â”€ else: 
â”‚   â”‚   â”‚   â”œâ”€â”€ refresh_session_if_needed() 
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ session_info = get_session_info(token) 
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ time_remaining = expires_at - now 
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ if time_remaining < 600: 
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ refreshed_token = refresh_session_token(token) 
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ set_session_token(refreshed_token) 
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ save_session_to_mongo() 
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ set_session_persistent() 
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ return True 
â”‚   â”‚   â”‚   â”œâ”€â”€ delete_mongo_session(token) 
â”‚   â”‚   â”‚   â””â”€â”€ clear_session() 
â”‚   â”‚   â””â”€â”€ return False 
â”‚   â””â”€â”€ else: 
â”‚       â”œâ”€â”€ clear_session() 
â”‚       â””â”€â”€ return False 
â””â”€â”€ return False
```

---

## ğŸ”„ Session Refresh Flow

### Automatic Token Renewal
```
refresh_session_if_needed() 
â”œâ”€â”€ token = get_session_token() 
â”œâ”€â”€ if token: 
â”‚   â”œâ”€â”€ session_info = get_session_info(token) 
â”‚   â”œâ”€â”€ if session_info: 
â”‚   â”‚   â”œâ”€â”€ time_remaining = expires_at - now 
â”‚   â”‚   â”œâ”€â”€ if time_remaining < 600: 
â”‚   â”‚   â”‚   â”œâ”€â”€ refreshed_token = refresh_session_token(token) 
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ jwt.decode(token, options={"verify_exp": False}) 
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ if time_until_expiry > 300: 
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ create_session_token(user_id, username) 
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ return None 
â”‚   â”‚   â”‚   â”œâ”€â”€ set_session_token(refreshed_token) 
â”‚   â”‚   â”‚   â”œâ”€â”€ save_session_to_mongo() 
â”‚   â”‚   â”‚   â””â”€â”€ set_session_persistent() 
â”‚   â”‚   â”‚   â””â”€â”€ return True 
â”‚   â”‚   â””â”€â”€ return False 
â””â”€â”€ return False
```

---

## ğŸšª Logout Flow

### Complete Session Cleanup
```
logout() 
â”œâ”€â”€ clear_session() 
â”‚   â”œâ”€â”€ token = get_session_token() 
â”‚   â”œâ”€â”€ if token: 
â”‚   â”‚   â””â”€â”€ delete_mongo_session(token) 
â”‚   â”‚       â””â”€â”€ db.sessions.update_one({token}, {"is_active": False}) 
â”‚   â”œâ”€â”€ st.session_state.token = None 
â”‚   â””â”€â”€ st.session_state.user = None 
â”œâ”€â”€ st.session_state.token = None 
â”œâ”€â”€ st.session_state.user = None 
â”œâ”€â”€ st.query_params.clear() 
â””â”€â”€ st.rerun()
```

---

## ğŸ”§ MongoDB Session Management

### Session Storage Operations
```
create_mongo_session(user_id, username, token) 
â”œâ”€â”€ cleanup_expired_sessions() 
â”‚   â”œâ”€â”€ db.sessions.update_many({expires_at < now, is_active: true}, {"is_active": false}) 
â”‚   â””â”€â”€ db.sessions.delete_many({created_at < 30_days_ago}) 
â”œâ”€â”€ session = {user_id, username, token, created_at, last_activity, expires_at, is_active} 
â””â”€â”€ db.sessions.insert_one(session)

get_mongo_session(token) 
â”œâ”€â”€ db.sessions.find_one({token, is_active: true, expires_at > now}) 
â””â”€â”€ db.sessions.update_one({_id}, {"last_activity": now})

update_mongo_session(token, user_data) 
â”œâ”€â”€ update_data = {"last_activity": now} 
â”œâ”€â”€ if user_data: 
â”‚   â””â”€â”€ update_data["user_data"] = user_data 
â””â”€â”€ db.sessions.update_one({token, is_active: true}, {"$set": update_data})

delete_mongo_session(token) 
â””â”€â”€ db.sessions.update_one({token}, {"is_active": false})
```

---

## ğŸ¯ Main App Session Display

### Session Status Indicators
```
main_app() 
â”œâ”€â”€ col1, col2, col3, col4 = st.columns([3, 1, 1, 1]) 
â”œâ”€â”€ with col1: 
â”‚   â””â”€â”€ st.title("ğŸ“ Scorix") 
â”œâ”€â”€ with col2: 
â”‚   â”œâ”€â”€ st.write(f"Welcome, {user['username']}!") 
â”‚   â”œâ”€â”€ session_info = get_session_info(st.session_state.token) 
â”‚   â”œâ”€â”€ if session_info: 
â”‚   â”‚   â”œâ”€â”€ if session_info['is_expired']: 
â”‚   â”‚   â”‚   â””â”€â”€ st.error("âš ï¸ Session expired") 
â”‚   â”‚   â”œâ”€â”€ else: 
â”‚   â”‚   â”‚   â”œâ”€â”€ time_remaining = expires_at - now 
â”‚   â”‚   â”‚   â”œâ”€â”€ if time_remaining > 3600: 
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ st.success("ğŸŸ¢ Session active (Xh Ym)") 
â”‚   â”‚   â”‚   â”œâ”€â”€ elif time_remaining > 300: 
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ st.warning("ğŸŸ¡ Session expires in Xm") 
â”‚   â”‚   â”‚   â””â”€â”€ else: 
â”‚   â”‚   â”‚       â””â”€â”€ st.error("ğŸ”´ Session expires in Xs") 
â”‚   â”œâ”€â”€ token = get_session_token() 
â”‚   â”œâ”€â”€ if token: 
â”‚   â”‚   â”œâ”€â”€ if 'token' in st.query_params: 
â”‚   â”‚   â”‚   â””â”€â”€ st.info("ğŸ”— Session persisted") 
â”‚   â”‚   â””â”€â”€ else: 
â”‚   â”‚       â””â”€â”€ st.warning("âš ï¸ Session not persisted") 
â”œâ”€â”€ with col3: 
â”‚   â””â”€â”€ st.button("ğŸ”„ Refresh Session") 
â”‚       â”œâ”€â”€ refreshed_token = refresh_session_token(st.session_state.token) 
â”‚       â”œâ”€â”€ set_session_token(refreshed_token) 
â”‚       â”œâ”€â”€ save_session_to_mongo() 
â”‚       â”œâ”€â”€ set_session_persistent() 
â”‚       â”œâ”€â”€ st.success("Session refreshed!") 
â”‚       â””â”€â”€ st.rerun() 
â””â”€â”€ with col4: 
    â””â”€â”€ st.button("ğŸšª Logout") 
        â””â”€â”€ logout()
```

---

## ğŸ” Debug Flow

### Session Troubleshooting
```
main() (with DEBUG_SESSION = True) 
â”œâ”€â”€ print("Session state:", {token, user, session_id}) 
â”œâ”€â”€ print("Query params:", dict(st.query_params)) 
â”œâ”€â”€ initialize_session() 
â”œâ”€â”€ print("Token after init:", token[:20] + "...") 
â”œâ”€â”€ print("User after init:", user['username']) 
â”œâ”€â”€ check_auth() 
â”œâ”€â”€ print("Auth checked - SUCCESS/FAILED") 
â”œâ”€â”€ refresh_session_if_needed() 
â”œâ”€â”€ print("Session refreshed") 
â”œâ”€â”€ main_app() 
â””â”€â”€ print("Main app finished")
```

---

## ğŸ“‹ Test Management Flow

### Test Creation Process
```
main_app() -> Test Management -> Create Test
â”œâ”€â”€ get_questions(user_id) 
â”œâ”€â”€ st.form("create_test_form") 
â”œâ”€â”€ test_name = st.text_input() 
â”œâ”€â”€ test_description = st.text_area() 
â”œâ”€â”€ for question in questions: 
â”‚   â””â”€â”€ st.checkbox() (select questions) 
â”œâ”€â”€ submitted = st.form_submit_button() 
â”œâ”€â”€ if submitted: 
â”‚   â”œâ”€â”€ validate test_name and selected_questions 
â”‚   â”œâ”€â”€ save_test(test_name, description, question_ids, user_id) 
â”‚   â””â”€â”€ st.rerun()
```

### Test Answer Upload
```
main_app() -> Test Management -> Upload Test Answers
â”œâ”€â”€ get_tests(user_id) 
â”œâ”€â”€ selected_test = st.selectbox() 
â”œâ”€â”€ get_test_by_id(test_id, user_id) 
â”œâ”€â”€ Manual Entry: 
â”‚   â”œâ”€â”€ st.form("manual_test_answer_form") 
â”‚   â”œâ”€â”€ student_name = st.text_input() 
â”‚   â”œâ”€â”€ student_roll_no = st.text_input() 
â”‚   â”œâ”€â”€ for question in test_questions: 
â”‚   â”‚   â””â”€â”€ answer = st.text_area() 
â”‚   â”œâ”€â”€ save_test_answer(name, roll, test_id, answers, user_id) 
â”‚   â””â”€â”€ st.rerun()
â”œâ”€â”€ CSV Upload: 
â”‚   â”œâ”€â”€ uploaded_file = st.file_uploader() 
â”‚   â”œâ”€â”€ import_export_service.import_test_answers_from_csv() 
â”‚   â””â”€â”€ st.rerun()
```

### Test Grading Process
```
main_app() -> Test Management -> Grade Tests
â”œâ”€â”€ get_tests(user_id) 
â”œâ”€â”€ selected_test = st.selectbox() 
â”œâ”€â”€ get_test_answers(user_id, test_id) 
â”œâ”€â”€ get_test_grades(user_id, test_id) 
â”œâ”€â”€ debug_mode = st.checkbox() 
â”œâ”€â”€ st.button("Grade Test & Save Results") 
â”‚   â”œâ”€â”€ clear_test_grades(user_id, test_id) 
â”‚   â”œâ”€â”€ grade_test(test_id, user_id, debug=debug_mode) 
â”‚   â”œâ”€â”€ save_test_grades(results, user_id) 
â”‚   â””â”€â”€ st.rerun()
â”œâ”€â”€ if test_grades exist: 
â”‚   â”œâ”€â”€ get_test_statistics(test_id, user_id) 
â”‚   â”œâ”€â”€ display metrics (total_students, average_percentage, etc.) 
â”‚   â””â”€â”€ display grade_distribution (A, B, C, D, F)
```

---

## ğŸ“¤ Data Management Flow

### Export Process
```
main_app() -> Data Management -> Export All Data
â”œâ”€â”€ st.button("Export All Data as ZIP") 
â”œâ”€â”€ import_export_service.export_questions_to_csv() 
â”œâ”€â”€ import_export_service.export_student_answers_to_csv() 
â”œâ”€â”€ import_export_service.export_grades_to_csv() 
â”œâ”€â”€ import_export_service.export_tests_to_csv() 
â”œâ”€â”€ import_export_service.export_test_answers_to_csv() 
â”œâ”€â”€ import_export_service.export_test_grades_to_csv() 
â”œâ”€â”€ zipfile.ZipFile() 
â”œâ”€â”€ zf.writestr() (add each CSV to ZIP) 
â”œâ”€â”€ st.download_button() 
â””â”€â”€ st.success("All data exported successfully!")
```

### Import Process
```
main_app() -> Data Management -> Import Answers
â”œâ”€â”€ get_questions(user_id) 
â”œâ”€â”€ selected_question = st.selectbox() 
â”œâ”€â”€ uploaded_file = st.file_uploader() 
â”œâ”€â”€ st.button("Import Answers") 
â”‚   â”œâ”€â”€ file_content = uploaded_file.read().decode('utf-8') 
â”‚   â”œâ”€â”€ import_export_service.import_student_answers_from_csv() 
â”‚   â”œâ”€â”€ display success/error messages 
â”‚   â”œâ”€â”€ display error details if any 
â”‚   â””â”€â”€ st.rerun()
```

### Bulk Operations
```
main_app() -> Data Management -> Bulk Operations
â”œâ”€â”€ Display current data counts 
â”œâ”€â”€ Clear Student Answers: 
â”‚   â”œâ”€â”€ confirm_answers = st.checkbox() 
â”‚   â”œâ”€â”€ st.form("clear_answers_form_bulk") 
â”‚   â”œâ”€â”€ db.answers.delete_many({"user_id": user_id}) 
â”‚   â””â”€â”€ st.success("Deleted X student answers")
â”œâ”€â”€ Clear Grades: 
â”‚   â”œâ”€â”€ confirm_grades = st.checkbox() 
â”‚   â”œâ”€â”€ st.form("clear_grades_form_bulk") 
â”‚   â”œâ”€â”€ db.grades.delete_many({"user_id": user_id}) 
â”‚   â””â”€â”€ st.success("Deleted X grades")
â”œâ”€â”€ Clear Test Grades: 
â”‚   â”œâ”€â”€ confirm_test_grades = st.checkbox() 
â”‚   â”œâ”€â”€ st.form("clear_test_grades_form_bulk") 
â”‚   â”œâ”€â”€ clear_test_grades(user_id) 
â”‚   â””â”€â”€ st.success("Cleared test grades")
â””â”€â”€ Clear Test Answers: 
    â”œâ”€â”€ confirm_test_answers = st.checkbox() 
    â”œâ”€â”€ st.form("clear_test_answers_form_bulk") 
    â”œâ”€â”€ db.test_answers.delete_many({"user_id": user_id}) 
    â””â”€â”€ st.success("Deleted X test answers")
```

---

## ğŸ¯ Grading Flow

### Individual Question Grading
```
main_app() -> Run Grading
â”œâ”€â”€ get_grade_thresholds(user_id) 
â”œâ”€â”€ display current thresholds 
â”œâ”€â”€ debug_mode = st.checkbox() 
â”œâ”€â”€ st.button("Run Grading & Save to DB") 
â”‚   â”œâ”€â”€ clear_grades(user_id) 
â”‚   â”œâ”€â”€ grade_all(debug=debug_mode, user_id=user_id) 
â”‚   â”œâ”€â”€ save_grades(results, user_id) 
â”‚   â””â”€â”€ st.session_state.grading_results = results
â”œâ”€â”€ get_questions(user_id) 
â”œâ”€â”€ get_student_answers(user_id) 
â”œâ”€â”€ get_grades(user_id) 
â”œâ”€â”€ selected_question = st.selectbox() 
â”œâ”€â”€ for question in questions: 
â”‚   â”œâ”€â”€ filter answers for this question 
â”‚   â”œâ”€â”€ filter grades for this question 
â”‚   â”œâ”€â”€ group answers by grade (A, B, C, D, F) 
â”‚   â”œâ”€â”€ display question details in expander 
â”‚   â”œâ”€â”€ for grade_category in grades: 
â”‚   â”‚   â”œâ”€â”€ display grade header 
â”‚   â”‚   â”œâ”€â”€ for answer in grade_answers: 
â”‚   â”‚   â”‚   â”œâ”€â”€ st.expander(student_name + score) 
â”‚   â”‚   â”‚   â”œâ”€â”€ st.text_area(student_answer) 
â”‚   â”‚   â”‚   â”œâ”€â”€ display score and grade 
â”‚   â”‚   â”‚   â”œâ”€â”€ display matched_rules 
â”‚   â”‚   â”‚   â””â”€â”€ display missed_rules 
â”‚   â”‚   â””â”€â”€ st.divider()
```

### Test Grading Process
```
grade_test(test_id, user_id, debug=False)
â”œâ”€â”€ get_test_by_id(test_id, user_id) 
â”œâ”€â”€ get_test_answers(user_id, test_id) 
â”œâ”€â”€ get_questions(user_id) 
â”œâ”€â”€ results = [] 
â”œâ”€â”€ for test_answer in test_answers: 
â”‚   â”œâ”€â”€ student_name = test_answer.student_name 
â”‚   â”œâ”€â”€ student_roll = test_answer.student_roll_no 
â”‚   â”œâ”€â”€ question_details = [] 
â”‚   â”œâ”€â”€ total_score = 0 
â”‚   â”œâ”€â”€ answered_questions = 0 
â”‚   â”œâ”€â”€ for question_id in test.question_ids: 
â”‚   â”‚   â”œâ”€â”€ question = find_question_by_id(question_id) 
â”‚   â”‚   â”œâ”€â”€ answer = test_answer.question_answers.get(question_id) 
â”‚   â”‚   â”œâ”€â”€ if answer: 
â”‚   â”‚   â”‚   â”œâ”€â”€ grade_question(question, answer, debug) 
â”‚   â”‚   â”‚   â”œâ”€â”€ question_details.append(result) 
â”‚   â”‚   â”‚   â”œâ”€â”€ total_score += result.score 
â”‚   â”‚   â”‚   â””â”€â”€ answered_questions += 1 
â”‚   â”‚   â””â”€â”€ else: 
â”‚   â”‚       â””â”€â”€ question_details.append(default_result)
â”‚   â”œâ”€â”€ overall_percentage = total_score / len(test.question_ids) 
â”‚   â”œâ”€â”€ overall_grade = calculate_grade(overall_percentage, thresholds) 
â”‚   â”œâ”€â”€ result = {student_name, student_roll, overall_percentage, overall_grade, question_details} 
â”‚   â””â”€â”€ results.append(result)
â””â”€â”€ return results
```

---

## ğŸ”§ Configuration Flow

### Grade Settings Management
```
main_app() -> Grade Settings
â”œâ”€â”€ get_grade_thresholds(user_id) 
â”œâ”€â”€ display current thresholds in metrics 
â”œâ”€â”€ st.form("grade_thresholds_form") 
â”‚   â”œâ”€â”€ a_threshold = st.number_input() 
â”‚   â”œâ”€â”€ b_threshold = st.number_input() 
â”‚   â”œâ”€â”€ c_threshold = st.number_input() 
â”‚   â”œâ”€â”€ d_threshold = st.number_input() 
â”‚   â”œâ”€â”€ validate thresholds (A > B > C > D) 
â”‚   â”œâ”€â”€ display preview with deltas 
â”‚   â”œâ”€â”€ submitted = st.form_submit_button() 
â”‚   â”œâ”€â”€ if submitted: 
â”‚   â”‚   â”œâ”€â”€ save_grade_thresholds(new_thresholds, user_id) 
â”‚   â”‚   â””â”€â”€ st.rerun()
â”œâ”€â”€ Quick Presets: 
â”‚   â”œâ”€â”€ st.button("Standard (85/70/55/40)") 
â”‚   â”œâ”€â”€ st.button("Strict (90/80/70/60)") 
â”‚   â””â”€â”€ st.button("Lenient (80/65/50/35)")
```

---

## ğŸ“Š Database Operations Flow

### Question Management
```
save_question(question, sample_answer, rules, user_id)
â”œâ”€â”€ get_db() 
â”œâ”€â”€ question_doc = {question, sample_answer, marking_scheme, user_id, created_at} 
â”œâ”€â”€ for rule in rules: 
â”‚   â”œâ”€â”€ rule_type = detect_rule_type(rule) 
â”‚   â””â”€â”€ marking_scheme.append({text: rule, type: rule_type})
â”œâ”€â”€ db.questions.insert_one(question_doc) 
â””â”€â”€ return success, message

get_questions(user_id)
â”œâ”€â”€ get_db() 
â””â”€â”€ db.questions.find({"user_id": user_id}).sort("created_at", -1)
```

### Answer Management
```
save_student_answer(name, roll_no, answer, question_id, user_id)
â”œâ”€â”€ get_db() 
â”œâ”€â”€ answer_doc = {student_name, student_roll_no, student_answer, question_id, user_id, created_at} 
â”œâ”€â”€ db.answers.insert_one(answer_doc) 
â””â”€â”€ return success, message

get_student_answers(user_id)
â”œâ”€â”€ get_db() 
â””â”€â”€ db.answers.find({"user_id": user_id}).sort("created_at", -1)
```

### Grade Management
```
save_grades(results, user_id)
â”œâ”€â”€ get_db() 
â”œâ”€â”€ for result in results: 
â”‚   â”œâ”€â”€ grade_doc = {question_id, student_roll_no, score, grade, matched_rules, missed_rules, user_id} 
â”‚   â””â”€â”€ db.grades.insert_one(grade_doc) 
â””â”€â”€ return success, message

get_grades(user_id)
â”œâ”€â”€ get_db() 
â””â”€â”€ db.grades.find({"user_id": user_id}).sort("created_at", -1)
```

---

## ğŸ” Error Handling Flow

### Session Errors
```
check_auth() -> Error Cases
â”œâ”€â”€ No token: return False 
â”œâ”€â”€ Invalid token: clear_session(), return False 
â”œâ”€â”€ Expired token: try refresh, if fails: clear_session(), return False 
â”œâ”€â”€ MongoDB connection error: clear_session(), return False 
â””â”€â”€ User not found: delete_mongo_session(), clear_session(), return False
```

### Grading Errors
```
grade_all() -> Error Cases
â”œâ”€â”€ No questions: return None 
â”œâ”€â”€ No answers: return None 
â”œâ”€â”€ Database error: log error, return None 
â”œâ”€â”€ Model loading error: log error, return None 
â””â”€â”€ Individual grading error: continue with next answer
```

### Import/Export Errors
```
import_student_answers_from_csv() -> Error Cases
â”œâ”€â”€ Invalid CSV format: return error message 
â”œâ”€â”€ Missing required columns: return error message 
â”œâ”€â”€ Invalid question_id: return error message 
â”œâ”€â”€ Database error: return error message 
â””â”€â”€ Partial success: return success with error list
```

---

## ğŸš€ Performance Considerations

### Session Optimization
- **MongoDB Indexing**: Index on token, user_id, expires_at
- **Session Cleanup**: Automatic cleanup of expired sessions
- **Connection Pooling**: Reuse database connections
- **Caching**: Cache frequently accessed user data

### Grading Optimization
- **Batch Processing**: Process multiple answers together
- **Model Caching**: Cache loaded AI models
- **Parallel Processing**: Use threading for large datasets
- **Memory Management**: Clear unused variables

### Database Optimization
- **Indexing**: Index on user_id, created_at, question_id
- **Aggregation**: Use MongoDB aggregation for statistics
- **Connection Management**: Proper connection pooling
- **Query Optimization**: Limit and sort efficiently

---

## ğŸ”§ Debugging Tools

### Session Debugging
```python
DEBUG_SESSION = True  # Enable in main()
# Outputs: Session state, query params, token info, user info, auth status
```

### Grading Debugging
```python
debug = True  # Enable in grading functions
# Outputs: Rule extraction, matching details, similarity scores, rule types
```

### Database Debugging
```python
# Check collections and documents
db.users.find().count()
db.sessions.find({"is_active": True}).count()
db.questions.find({"user_id": user_id}).count()
```

---

## ğŸ“ˆ Monitoring Points

### Session Health
- Active sessions count
- Session expiration rates
- Failed authentication attempts
- Session refresh success rate

### Grading Performance
- Average grading time per answer
- Model loading times
- Memory usage during grading
- Error rates in grading

### Database Performance
- Query response times
- Connection pool usage
- Index effectiveness
- Storage growth rate

---

## ğŸ›¡ï¸ Security Checkpoints

### Authentication Security
- JWT token validation
- Password hash verification
- Session expiration enforcement
- User data isolation

### Data Security
- Input validation and sanitization
- SQL injection prevention
- XSS protection
- CSRF protection

### Session Security
- Token encryption
- Session hijacking prevention
- Secure logout process
- Session fixation protection


